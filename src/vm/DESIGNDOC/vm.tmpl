       	       	    +---------------------------+
                    |           CS 124          |
                    | PROJECT 5: VIRTUAL MEMORY |
                    |      DESIGN DOCUMENT      |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Vaibhav Anand <vanand@caltech.edu>
Nikhil  Gupta <nkgupta@caltech.edu>
Michael Hashe <mhashe@caltech.edu>

>> Specify how many late tokens you are using on this assignment:  

0

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL:  https://github.com/MichaelHashe/CS124-OS
   commit        :  

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

Many of the commits for this assignment correspond to team members 
working on other team members computers.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

Stack overflow.

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.

Vaibhav: 
Nikhil : 
Michael: 

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

Vaibhav: Supplementary Page Table, sync, swap table
Nikhil : mmap, frame table, sync, paging
Michael: eviction, sync, dirty bits, stack growth, paging

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread {
    struct sup_entry ***sup_pagedir;    /*!< Supplemental page directory. */
};

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

First of all, if the data is already loaded into memory, it is already
loaded into the process's page table. As such, it will not page fault
and we will have nothing to handle. 

The way it does it through a one to one mapping. Given a virtual 
address, you can get a kernel virtual address through the process's 
page table. This kernel virtual address is in a one to one mapping 
with the frame table. The frame number is just some of the upper bits 
of the kernel virtual address.

If the frame is not currently loaded, the process will page fault
on an attempted load. The handler will check if the fault was due to 
an attempted access on the stack (discussed later) or something else.

If it is something else, the address is checked against the 
supplementary page table. This supplementary page table maintains
all the information about the location of the data, whether it is in
disk, swap, or memory.


>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

Whenever the accessed or dirty bits are needed, they are reconciled.
In particular, this means that we loop through all the elements in 
the supplementary page tables and check each of their accessed and 
dirty bits from the actual page table. These values are then or'ed 
with the corresponding accessed and dirty bit in the frame table. 

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We used a supplementary page table that exactly shadowed the 
original page table. This allowed us to have easy logic in keeping
the two in sync. Additionally, this means that we do not use an 
excessive amount of space because we can keep nested tables as 
NULL. Each entry in the supplementary page table is a struct 
which allows us to add as much information as we need for any
given entry.

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread {
    uint32_t num_stack_pages;           /*!< Number of pages in stack. */
};


---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When this happens, that means that the frame that process Q previously
had is now written to swap. This is kept track of in process Q's 
supplementary page table. In particular, in the entry, the frame 
number is given a certain invalid value and the swap slot is given
the number of the swap slot process Q now occupies. 


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make synchronization
>> easy, but limit parallelism.  On the other hand, using many locks
>> complicates synchronization and raises the possibility for deadlock
>> but allows for high parallelism.  Explain where your design falls
>> along this continuum and why you chose to design it this way.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

When a file is memory mapped, is lazily loaded such that supplemental 
table entries at the approriate addresses are create with the appropriate 
offsets in the file mapped. Then, when an address in the mapped region 
has a fault, the related entry is used to load the file's data from disk 
into an empty frame, which is then linked to the faulting virtual address.

When a page fault occurs, the address accessed is found in the supplemental 
page table for the process (if not, it terminates). If the fault 
is not a r/w i/o violation, it continues. If the entry in the supplemental 
table is installed in the swap table, it is loaded into an empty frame. Else,
the file for the entry is loaded from disk into an empty frame. The empty 
frame is then linked to the faulting virtual address. 

The only pages that are evicted are pages installed in the frame table 
(and not in the swap table).

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

Upon the load of a memory mapped file, we attempt to allocate all 
necessary segments in the supplemental page table. Since this table 
maintains the state of all potentially mapped objects for the process,
if any of the necessary segments are occupied, we know that the new 
file overlaps an existing segment. In particular, before we actually 
allocate any segment, we check to see that all the necessary segments
are unallocated.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

>> Any other comments?


